+++
title = "Notes on 'OCaml from the Very Beginning' by John Whitington."
date = 2022-07-23

[taxonomies]
tags = ["notes", "ocaml"]
+++

What follows are my notes from going through 'OCaml from the Very Beginning' by John Whitington, mostly in the form of answers to exercises and some observations and notes.

<!-- more -->

### Chapter 2

#### Question 1

```ocaml
let multiply_by_ten x = x * 10;;
val multiply_by_ten : int -> int = <fun>
```

The type of the function is `int -> int`, as expected. Given the strict wording of the question, it would have also been legitimate to define the function as follows:

```ocaml
let multiply_by_ten x = x *. 10.0;;
val multiply_by_ten : float -> float = <fun>
```

#### Question 2

```ocaml
let both_nonzero x y = (x != 0 && y != 0);;
val both_nonzero : int -> int -> bool = <fun>
```

Like the previous question, it would also be legitimate to answer with the following:

```ocaml
let both_nonzero x y = (x != 0.0 && y != 0.0);;
val both_nonzero : float -> float -> bool = <fun>
```

#### Question 3

```ocaml
let sum_to_n n = 
    let rec sum_rec i n = 
        if n == 0 
        then i 
        else sum_rec (i + n) (n - 1) 
    in sum_rec 0 n;;
val sum_to_n : int -> int = <fun>
```

Defining this function in terms of a recursive interior function allows for the sum to be collected in a 'hidden' interior variable. Defining the function in a recursive form like this is called "tail-call recursion". Like before, it would also be valid to define this function with `float` types, given the wording of the question. Omitted from this example are validity checks. For example, what if the initial `n` is less than 0? The function would enter an infinite recursive loop. 

#### Question 4

```ocaml
let power x n =
    let rec power_interior acc x n =
        if n == 0 then acc
        else power_interior (acc * x) x (n - 1)
    in power_interior 1 x n;;
val power : int -> int -> int = <fun>
```

#### Question 5

```ocaml
let isconsonant c = not (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' );;
val isconsonant : char -> bool = <fun>
```

Assuming the implementation of OCaml we're using 'short-circuits' such logical expressions, then:

```ocaml
let isconsonant c = not (c == 'e' || c == 'a' || c == 'i' || c == 'o' || c == 'u');;
```

Would be a (slightly) more efficient approach assuming statistical analysis of the English language applies in this situation. The letters 'E', then 'A', and so on in the order shown is in decreasing order of frequency in the English language. 

#### Question 6

```ocaml
let x = 1 in let x = 2 in x + x;;
```

Has type 'int'.

#### Question 7

The factorial function has definition:

```ocaml
let factorial n =
    let rec factorial_inner acc n =
        if n == 0 then acc
        else factorial_inner (acc * n) (n - 1)
    in factorial_inner 1 n;;
```

Non-termination of this function will occur in any case n < 0. One way of preventing this is to alter the base-case check.

```ocaml
let factorial n =
    let rec factorial_inner acc n =
        if ((<=) n 0) then acc
        else factorial_inner ((*) acc n) ((-) n 1)
    in factorial_inner 1 n;;
```
